<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>囲碁</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding-top: 20px;
      background: #eee;
    }
    canvas {
      background-color: #93d4f1;
      border: 2px solid #333;
    }
    .controls {
      margin: 10px;
    }
    button {
      margin: 0 5px;
      padding: 6px 12px;
    }
  </style>
</head>
<body>
  <canvas id="goban" width="600" height="600"></canvas>
  <div class="controls">
    <button id="passBtn">パス</button>
    <button id="resetBtn">リセット</button>
  </div>
  <div><span id="turn">黒</span></div>
  <div>くろはあと<span id="blackKingLibs">-</span></div>
  <div>しろはあと<span id="whiteKingLibs">-</span></div>

  <script>
    const canvas = document.getElementById("goban");
    const ctx = canvas.getContext("2d");
    const passBtn = document.getElementById("passBtn");
    const resetBtn = document.getElementById("resetBtn");
    const turnDisplay = document.getElementById("turn");
    const blackKingLibsDisplay = document.getElementById("blackKingLibs");
    const whiteKingLibsDisplay = document.getElementById("whiteKingLibs");

const kuronekoImg = new Image();
kuronekoImg.src = "./bin/kuroneko.png";
const kurokingImg = new Image();
kurokingImg.src = "./bin/kuroking.png";
const sironekoImg = new Image();
sironekoImg.src = "./bin/sironeko.png";
const sirokingImg = new Image();
sirokingImg.src = "./bin/siroking.png";


    const SIZE = 9;
    const CELL = canvas.width / (SIZE + 1);
    const OFFSET = CELL;

    let board = [];
    let drawBoard = [];
    let currentPlayer = "black";
    let aiEnabled = true;
    let blackKing = null;
    let whiteKing = null;
    let gameNow = true;

    function initBoard() {
      board = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));
      drawBoard = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));
      currentPlayer = "black";
      blackKing = null;
      whiteKing = null;
      updateDisplay();
      updateForbiddenPoints();
      draw();
    }

    function updateDisplay() {
      turnDisplay.textContent = currentPlayer === "black" ? "くろ（あなた）のばん" : "しろ（AI）のばん";
      blackKingLibsDisplay.textContent = blackKing ? countLiberties(blackKing.x, blackKing.y)+"て" : "-";
      whiteKingLibsDisplay.textContent = whiteKing ? countLiberties(whiteKing.x, whiteKing.y)+"て" : "-";
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#000";

      for (let i = 0; i < SIZE; i++) {
        let pos = OFFSET + i * CELL;
        ctx.beginPath();
        ctx.moveTo(OFFSET, pos);
        ctx.lineTo(OFFSET + (SIZE - 1) * CELL, pos);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(pos, OFFSET);
        ctx.lineTo(pos, OFFSET + (SIZE - 1) * CELL);
        ctx.stroke();
      }

      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          const val = board[y][x];
          const mark = drawBoard[y][x];
          const cx = OFFSET + x * CELL;
          const cy = OFFSET + y * CELL;

          if (val === "black" || val === "white") {
            if ((blackKing && blackKing.x === x && blackKing.y === y) ||  (whiteKing && whiteKing.x === x && whiteKing.y === y)) {
              const img = (val === "black") ? kurokingImg : sirokingImg;
              ctx.drawImage(img, cx - CELL * 0.55, cy - CELL * 0.55, CELL*1.1, CELL*1.1);
             } else {
              const img = (val === "black") ? kuronekoImg : sironekoImg;
              ctx.drawImage(img, cx - CELL * 0.5, cy - CELL * 0.5, CELL, CELL);
             }
          }else if (mark === "forbid_black" || mark === "forbid_white") {
            ctx.strokeStyle = mark === "forbid_black" ? "#fff" : "#000";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - CELL * 0.3, cy - CELL * 0.3);
            ctx.lineTo(cx + CELL * 0.3, cy + CELL * 0.3);
            ctx.moveTo(cx + CELL * 0.3, cy - CELL * 0.3);
            ctx.lineTo(cx - CELL * 0.3, cy + CELL * 0.3);
            ctx.stroke();
            ctx.lineWidth = 1;
          }


        }
      }
    }

    function getClosest(x, y) {
      for (let iy = 0; iy < SIZE; iy++) {
        for (let ix = 0; ix < SIZE; ix++) {
          const px = OFFSET + ix * CELL;
          const py = OFFSET + iy * CELL;
          if (Math.hypot(x - px, y - py) < CELL * 0.4) {
            return { x: ix, y: iy };
          }
        }
      }
      return null;
    }

    function getNeighbors(x, y) {
      return [
        [x - 1, y], [x + 1, y],
        [x, y - 1], [x, y + 1],
      ].filter(([nx, ny]) => nx >= 0 && ny >= 0 && nx < SIZE && ny < SIZE);
    }

    function hasLiberties(x, y, color, visited = {}) {
      const key = `${x},${y}`;
      if (visited[key]) return false;
      visited[key] = true;

      for (let [nx, ny] of getNeighbors(x, y)) {
        const val = board[ny][nx];
        if (val === null) return true;
        if (val === color && hasLiberties(nx, ny, color, visited)) return true;
      }
      return false;
    }

   function countLiberties(x, y, visited = {}) {
    const color = board[y][x];
    const checked = {};
    let count = 0;

    function dfs(cx, cy) {
      const key = `${cx},${cy}`;
      if (visited[key]) return;
      visited[key] = true;
      for (let [nx, ny] of getNeighbors(cx, cy)) {
        const nkey = `${nx},${ny}`;
        if (board[ny][nx] === null && !checked[nkey]) {
          checked[nkey] = true;
          count++;
        } else if (board[ny][nx] === color && !visited[`${nx},${ny}`]) {
          dfs(nx, ny);
        }
      }
    }
    dfs(x, y);
    return count;
  }
function removeDead(x, y, color) {
  const toRemove = [];
  const visited = {};

  function dfs(cx, cy) {
    const key = `${cx},${cy}`;
    if (visited[key]) return;
    visited[key] = true;
    toRemove.push([cx, cy]);

    for (let [nx, ny] of getNeighbors(cx, cy)) {
      if (board[ny][nx] === color) dfs(nx, ny);
    }
  }

  dfs(x, y);

  if (!hasLiberties(x, y, color, {})) {
    let kingCaptured = null;

    for (let [rx, ry] of toRemove) {
      // 王様が取られたことを検知するけど、情報はすぐに消さない
      if (blackKing && blackKing.x === rx && blackKing.y === ry) kingCaptured = "black";
      if (whiteKing && whiteKing.x === rx && whiteKing.y === ry) kingCaptured = "white";
      
      board[ry][rx] = null;
      drawBoard[ry][rx] = null;
    }

    draw(); // 盤面描画（消えた後の盤面）

    if (kingCaptured) {
      gameNow = false;

      // 勝敗メッセージを遅延表示し、表示後に盤面リセットする
      requestAnimationFrame(() => {
        setTimeout(() => {
          alert(kingCaptured === "black" ? "しろのかち！" : "くろのかち！");

          // 勝敗メッセージが出た後に王様情報を消し、初期化する
          if (kingCaptured === "black") blackKing = null;
          if (kingCaptured === "white") whiteKing = null;

          initBoard();
          gameNow = true;
        }, 100);
      });
    }
  }
}



function placeStone(x, y) {
  if (board[y][x] !== null) return false;

  board[y][x] = currentPlayer;

  if (!blackKing && currentPlayer === "black") blackKing = { x, y };
  if (!whiteKing && currentPlayer === "white") whiteKing = { x, y };

  for (let [nx, ny] of getNeighbors(x, y)) {
    const target = board[ny][nx];
    if (target && target !== currentPlayer) {
      removeDead(nx, ny, target);
    }
  }

  if (!hasLiberties(x, y, currentPlayer, {})) {
    board[y][x] = null;
    return false;
  }

  // ✅ 勝敗が決まったらこれ以上進ませない（ここが追加ポイント）
  if (!gameNow) return false;

  currentPlayer = currentPlayer === "black" ? "white" : "black";
  updateForbiddenPoints();
  updateDisplay();
  draw();
  return true;
}


    function updateForbiddenPoints() {
      drawBoard = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));

      for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
          if (board[y][x] !== null) continue;

          board[y][x] = "black";
          const blackSuicide = !hasLiberties(x, y, "black", {});
          board[y][x] = "white";
          const whiteSuicide = !hasLiberties(x, y, "white", {});
          board[y][x] = null;

          if (blackSuicide) drawBoard[y][x] = "forbid_black";
          if (whiteSuicide) drawBoard[y][x] = "forbid_white";
        }
      }
    }

    function aiMove() {
      if (!aiEnabled || currentPlayer !== "white" || !gameNow) return;
      const tengen=Math.floor(SIZE / 2);
      if (uteruka(tengen,tengen)){placeStone(tengen,tengen);return;}
      const candidates = [];

      for(let i=1;i<=tengen;i++){
        for (let y = tengen-i; y <= tengen+i; y++) {
          for (let x = tengen-i; x <= tengen+i; x++) {
            if (uteruka(x,y)) {
              candidates.push({ x, y });
            }
          }
        }
        if(candidates.length>0){
          const i = Math.floor(Math.random() * candidates.length);
          const { x, y } = candidates.splice(i, 1)[0];
          placeStone(x, y);
          return;
        }
      }
    }
    function uteruka(x,y){
       if (board[y][x] === null&&drawBoard[y][x] === null)return true;
       return false;
    }

canvas.addEventListener("click", (e) => {
  if (currentPlayer !== "black" || !gameNow) return;
  const rect = canvas.getBoundingClientRect();
  const point = getClosest(e.clientX - rect.left, e.clientY - rect.top);
  if (point && placeStone(point.x, point.y)) {
    setTimeout(aiMove, 300);
  }
});


    passBtn.addEventListener("click", () => {
      currentPlayer = currentPlayer === "black" ? "white" : "black";
      updateForbiddenPoints();
      updateDisplay();
      draw();
      if (currentPlayer === "white") setTimeout(aiMove, 300);
    });

    resetBtn.addEventListener("click", () => initBoard());

    initBoard();
  </script>
</body>
</html>
